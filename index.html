import React, { useState, useRef } from ‘react’;
import { Camera, Download, X, Settings } from ‘lucide-react’;

export default function PolaroidApp() {
const [images, setImages] = useState([]);
const [loading, setLoading] = useState(false);
const [vintageFilter, setVintageFilter] = useState(true);
const [dynamicSize, setDynamicSize] = useState(true);
const fileInputRef = useRef(null);
const canvasRefs = useRef([]);

const handleFileUpload = async (e) => {
const files = Array.from(e.target.files);
if (!files.length) return;

```
setLoading(true);
const newImages = [];

for (const file of files) {
  try {
    const imageUrl = await readFile(file);
    const processedCanvas = await processImage(imageUrl, file.name);
    newImages.push({
      id: Date.now() + Math.random(),
      canvas: processedCanvas,
      filename: file.name
    });
  } catch (error) {
    console.error('Error processing image:', error);
  }
}

setImages(prev => [...prev, ...newImages]);
setLoading(false);
```

};

const readFile = (file) => {
return new Promise((resolve, reject) => {
const reader = new FileReader();
reader.onload = (e) => resolve(e.target.result);
reader.onerror = reject;
reader.readAsDataURL(file);
});
};

const processImage = (imageUrl, filename) => {
return new Promise((resolve) => {
const img = new Image();
img.onload = () => {
const canvas = document.createElement(‘canvas’);
const ctx = canvas.getContext(‘2d’);
drawPolaroid(img, ctx, canvas);
resolve({ canvas, filename });
};
img.src = imageUrl;
});
};

const drawPolaroid = (img, ctx, canvas) => {
const MAX_DIMENSION = 1000;
const CLASSIC_DIMENSION = 350;

```
let drawWidth, drawHeight, sx, sy, sWidth, sHeight;

if (dynamicSize) {
  drawWidth = img.width;
  drawHeight = img.height;

  if (img.width > MAX_DIMENSION || img.height > MAX_DIMENSION) {
    const ratio = Math.min(MAX_DIMENSION / img.width, MAX_DIMENSION / img.height);
    drawWidth = img.width * ratio;
    drawHeight = img.height * ratio;
  }

  sx = 0;
  sy = 0;
  sWidth = img.width;
  sHeight = img.height;
} else {
  drawWidth = CLASSIC_DIMENSION;
  drawHeight = CLASSIC_DIMENSION;

  const imgAspectRatio = img.width / img.height;
  const canvasAspectRatio = 1.0;

  sx = 0;
  sy = 0;
  sWidth = img.width;
  sHeight = img.height;

  if (imgAspectRatio > canvasAspectRatio) {
    sWidth = img.height * canvasAspectRatio;
    sx = (img.width - sWidth) / 2;
  } else {
    sHeight = img.width / canvasAspectRatio;
    sy = (img.height - sHeight) / 2;
  }
}

const basePadding = Math.max(20, drawWidth * 0.05);
const paddingTop = basePadding;
const paddingLeft = basePadding;
const paddingBottom = dynamicSize ? Math.max(100, drawHeight * 0.2) : 100;

canvas.width = drawWidth + paddingLeft * 2;
canvas.height = drawHeight + paddingTop + paddingBottom;

// White frame
ctx.fillStyle = '#fdfdfd';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Paper texture
const textureDensity = 0.0005;
const numSpecks = (canvas.width * canvas.height) * textureDensity;
for (let i = 0; i < numSpecks; i++) {
  let x = Math.random() * canvas.width;
  let y = Math.random() * canvas.height;

  if (x < paddingLeft || x > paddingLeft + drawWidth || y < paddingTop || y > paddingTop + drawHeight) {
    let alpha = Math.random() * 0.1;
    let color = Math.random() > 0.5 ? 'rgba(0,0,0,' : 'rgba(255,255,255,';
    ctx.fillStyle = color + alpha + ')';
    ctx.fillRect(x, y, 1, 1);
  }
}

// Inner shadow
ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
ctx.shadowBlur = 8;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 2;
ctx.fillRect(paddingLeft, paddingTop, drawWidth, drawHeight);
ctx.shadowColor = 'transparent';

// Draw image
ctx.drawImage(img, sx, sy, sWidth, sHeight, paddingLeft, paddingTop, drawWidth, drawHeight);

// Vintage filters
if (vintageFilter) {
  ctx.globalCompositeOperation = 'overlay';
  ctx.fillStyle = 'rgba(255, 230, 200, 0.15)';
  ctx.fillRect(paddingLeft, paddingTop, drawWidth, drawHeight);

  ctx.globalCompositeOperation = 'source-over';
  const gradient = ctx.createRadialGradient(
    paddingLeft + drawWidth / 2, paddingTop + drawHeight / 2, drawWidth / 3,
    paddingLeft + drawWidth / 2, paddingTop + drawHeight / 2, drawWidth * 0.9
  );
  gradient.addColorStop(0, 'rgba(0,0,0,0)');
  gradient.addColorStop(1, 'rgba(0,0,0,0.3)');

  ctx.fillStyle = gradient;
  ctx.fillRect(paddingLeft, paddingTop, drawWidth, drawHeight);
}
```

};

const downloadImage = (canvas, filename) => {
const link = document.createElement(‘a’);
const safeName = filename.split(’.’)[0].replace(/[^a-z0-9]/gi, ‘_’);
link.download = `polaroid-${safeName}.png`;
link.href = canvas.toDataURL(‘image/png’);
link.click();
};

const downloadAll = () => {
images.forEach(img => {
downloadImage(img.canvas.canvas, img.canvas.filename);
});
};

const clearAll = () => {
setImages([]);
if (fileInputRef.current) fileInputRef.current.value = ‘’;
};

return (
<div className="min-h-screen bg-gradient-to-br from-indigo-50 via-white to-pink-50 p-4">
<div className="max-w-4xl mx-auto">
{/* Header */}
<div className="text-center mb-8 pt-8">
<div className="flex items-center justify-center mb-4">
<Camera className="w-12 h-12 text-indigo-600" />
</div>
<h1 className="text-4xl font-bold text-gray-800 mb-2">Polaroid-ify</h1>
<p className="text-gray-600">Transform your photos into vintage polaroids</p>
</div>

```
    {/* Controls */}
    <div className="bg-white rounded-2xl shadow-xl p-6 mb-6">
      <div className="flex flex-col gap-4">
        {/* Toggles */}
        <div className="flex flex-wrap gap-4 justify-center">
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="checkbox"
              checked={vintageFilter}
              onChange={(e) => setVintageFilter(e.target.checked)}
              className="w-4 h-4 text-indigo-600 rounded focus:ring-2 focus:ring-indigo-500"
            />
            <span className="text-sm text-gray-700">Vintage Filter</span>
          </label>

          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="checkbox"
              checked={dynamicSize}
              onChange={(e) => setDynamicSize(e.target.checked)}
              className="w-4 h-4 text-indigo-600 rounded focus:ring-2 focus:ring-indigo-500"
            />
            <span className="text-sm text-gray-700">Dynamic Sizing</span>
          </label>
        </div>

        {/* Upload Button */}
        <div className="text-center">
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            multiple
            onChange={handleFileUpload}
            className="hidden"
            id="file-upload"
          />
          <label
            htmlFor="file-upload"
            className="inline-flex items-center gap-2 px-6 py-3 bg-indigo-600 text-white rounded-xl font-medium hover:bg-indigo-700 transition-colors cursor-pointer shadow-lg hover:shadow-xl"
          >
            <Camera className="w-5 h-5" />
            Choose Photos
          </label>
        </div>

        {/* Action Buttons */}
        {images.length > 0 && (
          <div className="flex gap-2 justify-center">
            <button
              onClick={downloadAll}
              className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm"
            >
              <Download className="w-4 h-4" />
              Download All
            </button>
            <button
              onClick={clearAll}
              className="flex items-center gap-2 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors text-sm"
            >
              <X className="w-4 h-4" />
              Clear
            </button>
          </div>
        )}
      </div>
    </div>

    {/* Loading */}
    {loading && (
      <div className="text-center py-12">
        <div className="inline-block animate-spin rounded-full h-12 w-12 border-4 border-gray-200 border-t-indigo-600"></div>
        <p className="mt-4 text-gray-600">Processing your photos...</p>
      </div>
    )}

    {/* Results */}
    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
      {images.map((img, index) => (
        <div
          key={img.id}
          className="bg-white rounded-xl shadow-lg p-4 transform transition-transform hover:scale-105"
        >
          <div className="relative">
            <canvas
              ref={el => canvasRefs.current[index] = el}
              className="w-full h-auto rounded"
              width={img.canvas.canvas.width}
              height={img.canvas.canvas.height}
              style={{
                display: 'block',
                maxWidth: '100%',
                height: 'auto'
              }}
            />
            {/* Draw the canvas content */}
            {(() => {
              const canvas = canvasRefs.current[index];
              if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img.canvas.canvas, 0, 0);
              }
              return null;
            })()}
          </div>
          <button
            onClick={() => downloadImage(img.canvas.canvas, img.canvas.filename)}
            className="w-full mt-4 flex items-center justify-center gap-2 px-4 py-2 bg-gray-800 text-white rounded-lg hover:bg-gray-700 transition-colors"
          >
            <Download className="w-4 h-4" />
            Download
          </button>
        </div>
      ))}
    </div>

    {/* Instructions */}
    {images.length === 0 && !loading && (
      <div className="text-center py-12 text-gray-500">
        <Camera className="w-16 h-16 mx-auto mb-4 opacity-30" />
        <p>Upload photos to get started</p>
        <p className="text-sm mt-2">Supports JPG, PNG, and HEIC</p>
      </div>
    )}
  </div>
</div>
```

);
}
